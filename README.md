# **Stikhi-pirogi**

<h1>Введение</h1>
Целью данного проекта, была попытка создать алгоритм, генерирующий так называемые "стишки-пирожки" - четверостишия, написанные, как правило, белым (четырёхстопным) ямбом.

Для этого предполагалость:

<ul>
<li>Распарсить <a href='https://poetory.ru/pir/rating'>сайт</a> и собрать "пирожки" в отдельный файл</li>
<li>Создать на основе файла с "пирожками" json-список вида {'слово': 'коллокат1': 0.2(относительная частота), 'коллокат2': 0.8}</li>
<li>Используя библиотеку <a href='https://pypi.org/project/russtress/'>russtress</a> разметить каждое слово по не/ударным слогам и создать json-файл вида {"слово": "V'V"}</li>
<li>Построить алгоритм, принимающий на вход слово и, в соответствии с ударением (в попытке сохранить ямб), возвращающий следующее слово предложения</li>
<li>Оформить это в виде телеграм бота</li>
</ul>

<h1>Код</h1>
<h2>Пример использования</h2>

```python
from poet import Poem

poem = Poem()
poem.generate_token("bigram")
print(poem.show())
poem.clear()
```

<h1>Класс Poem</h1>
Класс хранит в себе переменную lines, в которую записываются строки стиха. В целом экземляр Poem() являет собой готовый генератор стишков всех типов.
<h2>Методы класса Poem</h2>

```python
generate_token(ngram, token) #метод, принимающий на вход тип n-грамы "unigram" или "bigram" и первую униграмму или биграмму соответственно
#Ничего не возвращает, лишь записывая стих в переменную класса lines (как и все методы generate_...)
```

```python
generate_markov(model=text_model) #принимает на вход текстовую модель, по умолчанию файл со стишками-пирожками
#записывает в lines стих, сгенерированный с помощью цепи Маркова
```

```python
show() #возвращает строку с готовым стихом
clear() #возвращает внутренние переменные класса к начальному состоянию
#Нужно вызывать после каждой генерации
```

<h2>Фильтрующая функция</h2>
При генерации по токенам для каждой уни/биграммы создается массив коллокатов, из которого с помощью numpy.random.choice() выбирается следующая уни/биграмма. Но перед этим список коллокатов фильтруется функцией filter(), чтобы оставить только те коллокаты, которые подходят по рифме. Ниже приведен алгоритм filter()
<br>
<br>
<br>
<img src="rhyme func diagram.svg">

<h1>Бот</h1>
Пожалуй единственное интересное замечание про бота это функция подписки, которая реализована в instruments/db_operator.py

```python
@bot.message_handler(commands=['sub'])
def subscribe(message):
    id = message.chat.id
    db.subscribe(id)
    bot.send_message(message.chat.id, "Вы подписались на ежечасную рассылку")

@bot.message_handler(commands=['unsub'])
def unsubscribe(message):
    id = message.chat.id
    db.unsubscribe(id)
    bot.send_message(message.chat.id, "Вы отписались от рассылки")
```

Функция использует библиотеку sqlite3 для создания базы данных из одного столбца, хранящей id чатов с подписанными пользователями. В будущем планируется добавить возможность регулировать периодичность подписки, так как сейчас она <i>ежечасная</i> для всех пользователей.